// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include "sw/device/coverage/printer.h"

#include <stdint.h>

#include "sw/device/lib/base/crc32.h"
#include "sw/device/lib/base/macros.h"

enum {
  // SHA-1 build ID
  kBuildIdSize = 20,

  // File magic: \x81OTCover
  kFileMagic = 0x7265766f43544f81ULL,
};

// symbols generated by linker.
extern char __llvm_prf_cnts_start[];
extern char __llvm_prf_cnts_end[];
extern char _build_id_start[];
extern char _build_id_end[];

#define BUILD_ID ((uint8_t *)_build_id_end - kBuildIdSize)

/**
 * When the linker finds a definition of this symbol, it knows to skip loading
 * the object which contains the profiling runtime's static initializer. See
 * https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#using-the-profiling-runtime-without-static-initializers
 * for more information.
 */

OT_SET_BSS_SECTION("__ot_coverage_bss", int __llvm_profile_runtime;
                   static uint32_t coverage_status;
                   static uint32_t coverage_crc; static char send_buf[0x100];);

void coverage_printer_sink_with_crc(const void *buf, size_t size) {
  const uint8_t *ptr = (const uint8_t *)buf;
  while (size) {
    size_t chunk_size = size > sizeof(send_buf) ? sizeof(send_buf) : size;
    for (int i = 0; i < chunk_size; ++i) {
      send_buf[i] = ptr[i];
    }
    crc32_add(&coverage_crc, send_buf, chunk_size);
    coverage_printer_sink(send_buf, chunk_size);
    size -= chunk_size;
    ptr += chunk_size;
  }
}

void coverage_compress_rle(uint8_t tag, uint32_t size) {
  uint32_t buf[2] = {0, size};
  if (size <= 0xfd) {
    // 00XX
    // [tag][size]
    buf[0] = 0x00000000 | ((uint32_t)tag << 24);
    coverage_printer_sink_with_crc((uint8_t *)buf + 3, 2);
  } else if (size <= 0xffff) {
    // 00feXXXX
    // [tag][fe][size]
    buf[0] = 0xfe000000 | ((uint32_t)tag << 16);
    coverage_printer_sink_with_crc((uint8_t *)buf + 2, 4);
  } else {
    // 00ffXXXXXX
    // [tag][ff][size]
    buf[0] = 0xff000000 | ((uint32_t)tag << 16);
    coverage_printer_sink_with_crc((uint8_t *)buf + 2, 5);
  }
}

void coverage_compress(unsigned char *data, size_t size) {
  size_t i = 0;

  // assumption: all bytes in data are either 0x00 or 0xff
  while (i < size) {
    // Find next span.
    size_t start = i;
    uint8_t tag = data[i++];
    while (i < size && data[i] == tag)
      i++;
    size_t span_size = i - start;

    // Check for fast alternating sequence
    if (span_size < 8 && start + 8 <= size) {
      // Pack next 8 bits as one byte, 0x00 as bit 1, 0xff as bit 0.
      uint8_t packed_byte = 0;
      for (uint8_t k = 0; k < 8; ++k) {
        packed_byte |= ((data[start + k] + 1) << k);
      }
      coverage_printer_sink_with_crc(&packed_byte, 1);
      i = start + 8;
    } else {
      coverage_compress_rle(tag, span_size);
    }
  }
}

void coverage_init(void) {
  if (!coverage_is_valid()) {
    // The linker script ensure the prf cnts section is aligned to 4-byte
    // boundary.
    uint32_t *ptr = (uint32_t *)__llvm_prf_cnts_start;
    while (ptr < (uint32_t *)__llvm_prf_cnts_end) {
      *ptr++ = 0xffffffff;
    }

    // Set the report as valid.
    coverage_status = *(uint32_t *)BUILD_ID;
  }
}

void coverage_printer_run(void) {
  crc32_init(&coverage_crc);

  const uint64_t magic = kFileMagic;
  coverage_printer_sink_with_crc(&magic, sizeof(magic));
  coverage_printer_sink_with_crc((unsigned char *)BUILD_ID, kBuildIdSize);

  size_t cnts_size =
      (size_t)__llvm_prf_cnts_end - (size_t)__llvm_prf_cnts_start;
  uint8_t *cnts = (uint8_t *)__llvm_prf_cnts_start;
  coverage_compress(cnts, cnts_size);

  coverage_crc = crc32_finish(&coverage_crc);
  coverage_printer_sink(&coverage_crc, sizeof(coverage_crc));
}

void coverage_invalidate(void) { coverage_status = 0x42; }

int coverage_is_valid(void) { return coverage_status == *(uint32_t *)BUILD_ID; }
